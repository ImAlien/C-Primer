# CppPrimer

## Chapter 12 动态内存

#### 12.1 动态内存和智能指针
* 静态内存存放静态对象，静态成员对象等；栈存放局部变量，均由编译器创建和销毁。堆是用于存放动态创建的对象。
* make_shared 会调用对象的构造函数来返回一个shared_ptr指针
* 类中const 和 非const（参数之后）是两个不同的重载，const对象调用const,非const对象调用非const
* 动态分配的类型只有调用了delete才会被释放，不会因为结束作用域而释放。
* shared_ptr的第二个参数可以是lambda表达式来代替原本的析构函数。
* 用了智能指针管理内存后，不应该再用内置指针，否则可能出现智能指针已经释放，而内置指针仍然指向内存。
* unique_ptr: 拷贝构造和拷贝赋值默认删除，可以通过移动构造来转移控制
* weak_ptr:由shared_ptr初始化而来，不改变shared_ptr的引用计数，用lock函数来判断指向对象是否存在；

#### 12.2 动态数组

## Chapter 13 拷贝控制

#### 13.1 拷贝，赋值，销毁
* 初始化时用=，还有传参时会调用拷贝构造函数； 语句中用=调用赋值构造函数

* 如果类中有成员的拷贝构造函数是deleted，更通用的说，如果有成员不能被拷贝，赋值，销毁，则默认的拷贝控制函数也是deleted

* 如果类需要析构函数，那么一定需要拷贝构造函数

* 拷贝构造函数和拷贝赋值函数是一起出现的


#### 13.2 拷贝控制与资源管理

* 赋值操作符：先拷贝右边的值到临时变量，再销毁左边存在的值，再把临时变量赋值到左边；(为了保证正确赋值给自己)

#### 13.5 管理动态内存的类
* 静态变量除了在类中声明，还需要在类外定义
* reserve是对cap来说的，resize是对于size而言；reserve只对空间进行操作，resize可能会减少或者增加元素;

#### 13.6 移动对象
* 右值
    * 右值引用：右值引用指向那些将要被销毁的对象
    * 变量是左值，即使它被定义为一个右值引用
    * 可以通过std::move 将左值转化为右值
* 移动构造函数
    * 移动构造函数用noexcept来保证不抛出异常
    * 不抛出异常的原因是保证库容器正常使用，比如vector重分配的时候
* 移动赋值函数：注意自检测和释放原先的资源
* 没有定义拷贝控制成员时，移动构造函数和移动赋值函数才会被编译器合成




## Chapter 15 OOP

#### 15.1 Overview

引入了父类和子类,
还有引用和指针的动态绑定

#### 15.2 基类和派生类

* 子类到父类的转换是隐式的(指针和引用，如果是对象的话需要通过初始化或者拷贝构造函数)，没有父类到子类的隐式转换

* final 关键字可以阻止继承

* 静态类型是编译时就已经知道的，动态类型是运行是才能知道的：
只有指向基类的指针或者引用，他们的动态类型才可能跟静态类型不一样。

#### 15.3 虚函数

* 虚函数的调用可能在运行时才被解析

* override 关键字表示重写虚函数

* final 关键字表示虚函数不允许子类重写
* 虚函数的默认参数都需要一致

* 可以使用范围操作符 :: 来使用基类的虚函数

#### 15.4 抽象类

* 抽象类不能被实例化，
* 纯虚函数:在声明末尾加上=0，可以被定义（在类外），也可以不定义
* 子类的构造初始化应该只调用它直接基类的构造函数

#### 访问控制和继承

* protect： 能允许子类访问子类自己的函数或成员变量， private: 不允许子类访问，子类要访问的话跟用户一样调用接口

* public 继承：所有成员维持访问权限；protect：public降为protect；private:权限降为private；（这里的权限都是指用户或者当前类的派生类的权限，该类对基类的访问由基类的访问控制符决定）
* friend： 友元类没有特殊的访问

* 当protected和private时，外部调用子类到父类隐式转换失效；（子类不能当父类用？）
* 可以通过uising声明来维持一些不想降权限的函数和成员。

* struct 默认是public继承，class 默认是private继承

#### 15.6 类的作用域

* 向上查询：遇到当前类没有的函数，会向基类查询，这发生在编译阶段

* 命名冲突：子类中有基类的成员或者函数时，会把基类的成员和函数隐藏。但是还是在子类中存在，可以通过 :: 来访问；

* 如果调用的函数是虚函数，则会在运行时再决定调用哪个虚函数。

* 命名向上查询会在类型检查之前，一旦命名找到，则不再继续向上，因此如果子类隐藏了基类的函数，则不会再找基类的函数。

#### 15.7 构造函数和拷贝控制

* 虚析构函数关闭了合成的移动函数
* 基类函数被定义为delete，则子类函数也会被定义为delete

#### 15.8 容器与继承

* 如果要实现多态的话，应该把（智能）指针放在容器中
* 对于set,map，如果指针作为key的话，要自定义排序函数




